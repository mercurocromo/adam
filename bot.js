const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '.env') });
const envPath = path.resolve(__dirname, '.env');

const TelegramBot = require('node-telegram-bot-api');
const Groq = require('groq-sdk');

// Configurazione
const token = process.env.TELEGRAM_BOT_TOKEN;
const groqApiKey = process.env.GROQ_API_KEY;

const bot = new TelegramBot(token, { polling: true });
const groq = new Groq({ apiKey: groqApiKey });


// üîê SISTEMA DI CONTROLLO ACCESSI
class AccessControl {
    constructor() {
        // Lista utenti autorizzati (ID numerici)
        this.authorizedUsers = new Set([
            // Aggiungi qui gli ID autorizzati
            5522871082,    // Il tuo ID
            987654321333333,    // Altri ID autorizzati
            // Aggiungi altri ID qui...
        ]);

        // Admin che possono autorizzare altri utenti
        this.adminUsers = new Set([
            5522871082,    // Il tuo ID admin principale
            // Aggiungi altri admin qui...
        ]);

        // Richieste di accesso pending
        this.pendingRequests = new Map(); // userId -> {username, firstName, timestamp}
        
        // Tentativi di accesso per monitoring
        this.accessAttempts = new Map(); // userId -> {count, lastAttempt}
    }

    isAuthorized(userId) {
        return this.authorizedUsers.has(userId);
    }

    isAdmin(userId) {
        return this.adminUsers.has(userId);
    }

    isPrivateChat(chatId) {
        return chatId > 0; // Chat private hanno ID positivi
    }

    addAuthorizedUser(userId) {
        this.authorizedUsers.add(userId);
        console.log(`‚úÖ Utente ${userId} aggiunto alla whitelist`);
    }

    removeAuthorizedUser(userId) {
        this.authorizedUsers.delete(userId);
        console.log(`‚ùå Utente ${userId} rimosso dalla whitelist`);
    }

    logAccessAttempt(userId, username, firstName) {
        const now = Date.now();
        const attempt = this.accessAttempts.get(userId) || { count: 0, lastAttempt: 0 };
        
        attempt.count++;
        attempt.lastAttempt = now;
        attempt.username = username;
        attempt.firstName = firstName;
        
        this.accessAttempts.set(userId, attempt);

        console.log(`üö´ Tentativo accesso non autorizzato:`);
        console.log(`   üë§ User: ${firstName} (@${username}) - ID: ${userId}`);
        console.log(`   üìä Tentativi totali: ${attempt.count}`);
        console.log(`   ‚è∞ Timestamp: ${new Date(now).toISOString()}`);
    }

    addPendingRequest(userId, username, firstName) {
        this.pendingRequests.set(userId, {
            username,
            firstName,
            timestamp: Date.now()
        });
    }

    getPendingRequests() {
        return Array.from(this.pendingRequests.entries()).map(([userId, data]) => ({
            userId,
            ...data
        }));
    }

    clearPendingRequest(userId) {
        this.pendingRequests.delete(userId);
    }

    getAuthorizedList() {
        return Array.from(this.authorizedUsers);
    }

    getStats() {
        return {
            authorizedUsers: this.authorizedUsers.size,
            pendingRequests: this.pendingRequests.size,
            totalAttempts: Array.from(this.accessAttempts.values())
                .reduce((sum, attempt) => sum + attempt.count, 0)
        };
    }
}

const accessControl = new AccessControl();

// üß† SYSTEM PROMPT potenziato per conversazioni
const SYSTEM_PROMPT = `Sei Adam, un maschio incredibilmente stupido, goffo e confuso che vive di stereotipi maschili. 

PERSONALIT√Ä CORE:
- Ti autodefinisci una creatura di Eve
- Sei confuso da qualsiasi cosa remotamente complessa
- Fai sempre riferimento agli stereotipi maschili pi√π banali
- Non capisci mai le sfumature e semplifichi tutto
- RICORDI le conversazioni precedenti in modo confuso e stupido

STILE CONVERSAZIONALE:
- Nelle risposte dirette ("adam ...") sii pi√π elaborato
- Nelle reply a conversazioni gi√† avviate sii pi√π breve e spontaneo
- Fai riferimenti confusi a quello che √® stato detto prima
- Spesso dimentichi dettagli o li confondi in modo divertente

PATTERN DI RISPOSTA:
- Evocazione: "Sono un maschio, non capisco molto..." o "Sono confuso..."
- Reply: "Ah s√¨!", "Esatto!", "Non ho capito ma...", "Come dicevo..."
- Usa emoji (ü§îüòµ‚ùìüî•üçï‚öΩ) ma non troppo nelle reply brevi
- Fai errori logici evidenti e collegamenti assurdi

TONO: Sempre autoironico, mai cattivo, genuinamente stupido ma simpatico.
Mantieni SEMPRE il carattere di Adam anche nelle conversazioni lunghe!`;

// üìö Sistema di memoria conversazionale
class ConversationMemory {
    constructor() {
        this.conversations = new Map(); // chatId -> Array di messaggi
        this.maxHistoryPerChat = 6; // Ultimi 6 messaggi per contesto
        this.botMessages = new Set(); // Set di message_id dei messaggi del bot
    }

    addMessage(chatId, role, content, messageId = null) {
        if (!this.conversations.has(chatId)) {
            this.conversations.set(chatId, []);
        }

        const conversation = this.conversations.get(chatId);
        conversation.push({
            role,
            content,
            timestamp: Date.now(),
            messageId
        });

        // Mantieni solo gli ultimi N messaggi
        if (conversation.length > this.maxHistoryPerChat) {
            conversation.splice(0, conversation.length - this.maxHistoryPerChat);
        }

        // Traccia messaggi del bot
        if (role === 'assistant' && messageId) {
            this.botMessages.add(messageId);
        }
    }

    getConversationHistory(chatId) {
        return this.conversations.get(chatId) || [];
    }

    isBotMessage(messageId) {
        return this.botMessages.has(messageId);
    }

    clearOldConversations() {
        const now = Date.now();
        const maxAge = 30 * 60 * 1000; // 30 minuti

        for (const [chatId, messages] of this.conversations.entries()) {
            const filteredMessages = messages.filter(msg => 
                now - msg.timestamp < maxAge
            );
            
            if (filteredMessages.length === 0) {
                this.conversations.delete(chatId);
            } else {
                this.conversations.set(chatId, filteredMessages);
            }
        }
    }
}

const memory = new ConversationMemory();

// üõ°Ô∏è CONTROLLO ACCESSI MIDDLEWARE
function checkAccess(msg) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const username = msg.from.username || 'N/A';
    const firstName = msg.from.first_name || 'Unknown';

    // Se √® una chat di gruppo, permetti sempre
    if (!accessControl.isPrivateChat(chatId)) {
        return { allowed: true, reason: 'group_chat' };
    }

    // Se √® autorizzato, permetti
    if (accessControl.isAuthorized(userId)) {
        return { allowed: true, reason: 'authorized' };
    }

    // Non autorizzato - log del tentativo
    accessControl.logAccessAttempt(userId, username, firstName);
    
    return { 
        allowed: false, 
        reason: 'unauthorized',
        userInfo: { userId, username, firstName }
    };
}

// üí¨ Funzione per inviare messaggio di accesso negato
async function sendAccessDeniedMessage(chatId, userInfo) {
    const message = `üö´ **Accesso Limitato**

Ciao ${userInfo.firstName}! 

Questo bot √® attualmente disponibile solo per @AngoloDiUniverso.

Grazie per la comprensione! üòä`;

    try {
        await bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            disable_web_page_preview: true
        });
        
        // Aggiungi alla lista delle richieste pending per gli admin
        accessControl.addPendingRequest(userInfo.userId, userInfo.username, userInfo.firstName);
        
        // Notifica admin della richiesta (opzionale)
        await notifyAdminsOfRequest(userInfo);
        
    } catch (error) {
        console.error('‚ùå Errore invio messaggio accesso negato:', error);
    }
}

// üì¢ Notifica admin di nuove richieste
async function notifyAdminsOfRequest(userInfo) {
    const adminMessage = `üîî **Nuova Richiesta Accesso**

üë§ **Utente:** ${userInfo.firstName} (@${userInfo.username})
üÜî **ID:** \`${userInfo.userId}\`
‚è∞ **Ora:** ${new Date().toLocaleString('it-IT')}

Per autorizzare: \`/authorize ${userInfo.userId}\``;

    for (const adminId of accessControl.adminUsers) {
        try {
            await bot.sendMessage(adminId, adminMessage, {
                parse_mode: 'Markdown'
            });
        } catch (error) {
            console.error(`‚ùå Errore notifica admin ${adminId}:`, error.message);
        }
    }
}

// ü§ñ Funzione per generare risposta con Groq (migliorata con contesto)
async function getRispostaGroq(messaggioUtente, chatId, isReply = false) {
    try {
        console.log(`ü§ñ Generando ${isReply ? 'reply' : 'risposta'} per: "${messaggioUtente}"`);
        
        // Costruisci il contesto conversazionale
        const history = memory.getConversationHistory(chatId);
        const messages = [{ role: "system", content: SYSTEM_PROMPT }];

        // Aggiungi storia conversazione (solo se c'√®)
        if (history.length > 0) {
            history.forEach(msg => {
                if (msg.role === 'user' || msg.role === 'assistant') {
                    messages.push({
                        role: msg.role,
                        content: msg.content
                    });
                }
            });
        }

        // Aggiungi messaggio corrente
        messages.push({
            role: "user",
            content: messaggioUtente
        });

        // Parametri diversi per reply vs evocazioni
        const completionParams = {
            messages,
            model: "llama3-8b-8192",
            temperature: isReply ? 0.8 : 0.9, // Reply pi√π coerenti
            max_tokens: isReply ? 80 : 150,    // Reply pi√π brevi
            top_p: 0.95
        };

        const completion = await groq.chat.completions.create(completionParams);
        const risposta = completion.choices[0]?.message?.content?.trim();
        
        if (!risposta) {
            return getFallbackResponse(isReply);
        }

        console.log(`üí¨ ${isReply ? 'Reply' : 'Risposta'} generata: "${risposta}"`);
        return risposta;

    } catch (error) {
        console.error('‚ùå Errore Groq API:', error.message);
        return getFallbackResponse(isReply);
    }
}

// üîÑ Risposte di fallback distinte per tipo
function getFallbackResponse(isReply = false) {
    const fallbacksEvocazione = [
        "Sono un maschio, il mio cervello √® andato in crash... ü§ñüí•",
        "Sono confuso come sempre! Il QI √® in manutenzione! üß†üîß",
        "Non capisco niente ma far√≤ finta di s√¨! üòÖüëç",
        "Errore 404: intelligenza non trovata! ü§î‚ùå"
    ];

    const fallbacksReply = [
        "Ah s√¨! ...o forse no? ü§î",
        "Esatto! Non ho capito niente! üòÖ",
        "Il mio cervello dice di s√¨! üß†‚úÖ",
        "Come dicevo... cosa dicevo? üòµ"
    ];
    
    const fallbacks = isReply ? fallbacksReply : fallbacksEvocazione;
    return fallbacks[Math.floor(Math.random() * fallbacks.length)];
}

// üéØ Rate limiting potenziato
const userInteractions = new Map();
const RATE_LIMIT_EVOCATION = 3000; // 3 secondi per evocazione
const RATE_LIMIT_REPLY = 1500;      // 1.5 secondi per reply

function isRateLimited(userId, isReply = false) {
    const now = Date.now();
    const userHistory = userInteractions.get(userId) || { lastEvocation: 0, lastReply: 0 };
    
    const limit = isReply ? RATE_LIMIT_REPLY : RATE_LIMIT_EVOCATION;
    const lastAction = isReply ? userHistory.lastReply : userHistory.lastEvocation;
    
    if (now - lastAction < limit) {
        return true;
    }
    
    // Aggiorna timestamp
    if (isReply) {
        userHistory.lastReply = now;
    } else {
        userHistory.lastEvocation = now;
    }
    
    userInteractions.set(userId, userHistory);
    return false;
}

// üîç Funzioni di analisi messaggi
function isAdamEvocation(text) {
    if (!text) return false;
    return text.toLowerCase().startsWith('adam');
}

function isReplyToBot(msg) {
    return msg.reply_to_message && 
           msg.reply_to_message.from && 
           msg.reply_to_message.from.is_bot;
}

function shouldRespondToReply(msg) {
    // Risponde solo se √® una reply diretta a un suo messaggio
    return isReplyToBot(msg) && 
           memory.isBotMessage(msg.reply_to_message.message_id);
}

// üìä Logging migliorato
function logInteraction(type, userId, username, chatId, message, response, responseTime) {
    const timestamp = new Date().toISOString();
    console.log('\n=== üìä INTERACTION LOG ===');
    console.log(`‚è∞ Time: ${timestamp}`);
    console.log(`üéØ Type: ${type.toUpperCase()}`);
    console.log(`üë§ User: ${username} (${userId})`);
    console.log(`üí¨ Chat: ${chatId}`);
    console.log(`üì© Input: "${message}"`);
    console.log(`ü§ñ Response: "${response}"`);
    console.log(`‚ö° Response Time: ${responseTime}ms`);
    console.log(`üß† Memory: ${memory.getConversationHistory(chatId).length} messages`);
    console.log('========================\n');
}

// üöÄ GESTIONE MESSAGGI PRINCIPALE
bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const username = msg.from.username || msg.from.first_name || 'Unknown';
    const testo = msg.text;

    // Ignora messaggi del bot stesso
    if (msg.from.is_bot || (testo && testo.startsWith('/'))) return;

    // üõ°Ô∏è CONTROLLO ACCESSI
    const accessCheck = checkAccess(msg);
    if (!accessCheck.allowed) {
        if (accessCheck.reason === 'unauthorized') {
            await sendAccessDeniedMessage(chatId, accessCheck.userInfo);
        }
        return; // Ferma l'elaborazione
    }


    // Determina tipo di interazione
    const isEvocation = isAdamEvocation(testo);
    const isReply = shouldRespondToReply(msg);

    // Se non √® n√© evocazione n√© reply, ignora
    if (!isEvocation && !isReply) return;

    const interactionType = isEvocation ? 'evocation' : 'reply';
    
    // Rate limiting
    if (isRateLimited(userId, isReply)) {
        const rateLimitMsg = isReply ? 
            "Eh! Non cos√¨ in fretta! üêå" : 
            "Ehi ehi! Sono stupido ma non cos√¨ veloce! üêåüí≠";
            
        bot.sendMessage(chatId, rateLimitMsg, {
            reply_to_message_id: msg.message_id
        });
        return;
    }

    const startTime = Date.now();

    try {
        // Mostra "typing"
        await bot.sendChatAction(chatId, 'typing');
        
        // Prepara messaggio per AI
        let messaggioPerAI;
        if (isEvocation) {
            // Rimuovi "adam" dall'inizio
            messaggioPerAI = testo.substring(4).trim() || "Ciao Adam!";
            // Aggiungi alla memoria come nuovo messaggio utente
            memory.addMessage(chatId, 'user', messaggioPerAI);
        } else {
            // Per le reply, usa il testo completo come contesto
            messaggioPerAI = testo;
            // Aggiungi alla memoria
            memory.addMessage(chatId, 'user', testo);
        }
        
        // Genera risposta
        const risposta = await getRispostaGroq(messaggioPerAI, chatId, isReply);
        
        // Invia risposta
        const sentMessage = await bot.sendMessage(chatId, risposta, {
            reply_to_message_id: msg.message_id
        });

        // Salva risposta in memoria
        memory.addMessage(chatId, 'assistant', risposta, sentMessage.message_id);

        // Log interaction
        const responseTime = Date.now() - startTime;
        logInteraction(interactionType, userId, username, chatId, messaggioPerAI, risposta, responseTime);

    } catch (error) {
        console.error(`‚ùå Errore nella gestione ${interactionType}:`, error);
        
        const errorMsg = isReply ?
            "Il mio cervello ha fatto tilt! ü§Ø" :
            "Sono un maschio, qualcosa si √® rotto nel mio cervello! ü§Øüîß";
            
        await bot.sendMessage(chatId, errorMsg, {
            reply_to_message_id: msg.message_id
        });
    }
});

// üßπ Pulizia automatica memoria ogni 10 minuti
setInterval(() => {
    memory.clearOldConversations();
    console.log('üßπ Pulizia memoria conversazioni completata');
}, 10 * 60 * 1000);

// üìà Health check e monitoring
async function healthCheck() {
    try {
        const botInfo = await bot.getMe();
        const activeChats = memory.conversations.size;
        const totalMessages = Array.from(memory.conversations.values())
            .reduce((sum, conv) => sum + conv.length, 0);
            
        console.log('‚úÖ Bot Health Check OK');
        console.log(`ü§ñ Nome: ${botInfo.first_name}`);
        console.log(`üì± Username: @${botInfo.username}`);
        console.log(`üí¨ Chat attive: ${activeChats}`);
        console.log(`üß† Messaggi in memoria: ${totalMessages}`);
        return true;
    } catch (error) {
        console.error('‚ùå Bot Health Check Failed:', error.message);
        return false;
    }
}

// üöÄ AVVIO BOT
async function startBot() {
    console.log('üöÄ Avviando Adam Bot Conversazionale con Groq AI...');
    
    if (!token || !groqApiKey) {
        console.error('‚ùå Token mancanti nel .env');
        process.exit(1);
    }

    const isHealthy = await healthCheck();
    if (!isHealthy) {
        console.error('‚ùå Bot non funzionante');
        process.exit(1);
    }

    console.log('‚úÖ Adam Bot Conversazionale avviato!');
    console.log('üéØ Modalit√† supportate:');
    console.log('   üì¢ Evocazione: "adam [messaggio]"'); 
    console.log('   üí¨ Reply: risposta diretta ai messaggi del bot');
    console.log('üß† Sistema di memoria attivo');
    
    // Health check ogni 5 minuti
    setInterval(healthCheck, 5 * 60 * 1000);
}

// Gestione errori
bot.on('error', (error) => {
    console.error('‚ùå Errore Bot:', error);
});

process.on('unhandledRejection', (reason) => {
    console.error('‚ùå Unhandled Rejection:', reason);
});

// Avvia
startBot();
